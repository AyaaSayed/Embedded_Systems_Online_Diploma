/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

typedef volatile unsigned int vuint32;

// GPIO

// Port A
#define GPIOA_BASE 0x40010800
#define GPIOA_CRL (*(vuint32 *)(GPIOA_BASE + 0x00))
#define GPIOA_CRH (*(vuint32 *)(GPIOA_BASE + 0x04))
#define GPIOA_IDR (*(vuint32 *)(GPIOA_BASE + 0x08))

// Port B
#define GPIOB_BASE 0x40010C00
#define GPIOB_CRL (*(vuint32 *)(GPIOB_BASE + 0x00))
#define GPIOB_CRH (*(vuint32 *)(GPIOB_BASE + 0x04))
#define GPIOB_ODR (*(vuint32 *)(GPIOB_BASE + 0x0C))

// GPIOx_CRL pins
#define MODE1 4 // Mode for Px1
#define CNF1 6 // Configuration bit for Px1

// GPIOx_CRH pins
#define MODE13 20 // Mode of Px13
#define CNF13 22 // Configuration bit for Px13

// GPIOx_IDR pins
#define IDR1 1 // Position of pin 1
#define IDR13 13 // Position of pin 13

// GPIOx_ODR pins
#define ODR1 1 // Position of pin 1
#define ODR13 13 // Position of pin 13
//--------------------------------------------------

// RCC
#define RCC_BASE 0x40021000
#define RCC_APB2ENR (*(vuint32 *)(RCC_BASE + 0x18))

// RCC_APB2ENR pins
#define IOPAEN 2 // Enable Port A
#define IOPBEN 3 // Enable Port B
//--------------------------------------------------

// Useful Macro
#define READ_PIN(reg, pin_num) (((reg) & (1 << (pin_num))) >> (pin_num))
#define TOGGLE_PIN(reg, pin_num) ((reg) ^= (1 << (pin_num)))

//--------------------------------------------------

// Prototypes
void hardware_init(void);
void GPIO_init(void);
void clock_init(void);
void delay(unsigned int count);

//--------------------------------------------------


int main(void)
{
	// Clock for APB2 + GPIOA + GPIOB
	hardware_init();

	// Stay here forever
	while(1)
	{
		if(READ_PIN(GPIOA_IDR, IDR1) == 0)
		{
			TOGGLE_PIN(GPIOB_ODR, ODR1);

			// Wait for single-press to finally release
			while(READ_PIN(GPIOA_IDR, IDR1) == 0);
		}


		if(READ_PIN(GPIOA_IDR, IDR13) == 1)
		{
			// Continue updating status as it's a multi-press
			TOGGLE_PIN(GPIOB_ODR, ODR13);
		}

		delay(1);
	}
}

void hardware_init(void)
{
	clock_init();
	GPIO_init();
}

void GPIO_init(void)
{
	// GPIOA settings
	// Pin 1
	// Mode: Input Mode
	GPIOA_CRL &= ~(0b11 << MODE1);
	// Configuration: Floating (Pull-up externally)
	GPIOA_CRL |= (1 << CNF1);

	// Pin 13
	// Mode: Input Mode
	GPIOA_CRH &= ~(0b11 << MODE13);
	// Configuration: Floating (Pull-down externally)
	GPIOA_CRH |= (1 << CNF13);

	//--------------------------------------------------

	// GPIOB settings
	// Pin 1
	// Mode: Output Mode, max speed = 2 MHz
	GPIOB_CRL |= (0b10 << MODE1);
	// Configuration: Push-pull
	GPIOB_CRL &= ~(0b11 << CNF1);

	// Pin 13
	// Mode: Output Mode, max speed = 2 MHz
	GPIOB_CRH |= (0b10 << MODE13);
	// Configuration: Push-pull
	GPIOB_CRH &= ~(0b11 << CNF13);
}

void clock_init(void)
{
	// Enable clock for IO PortA
	RCC_APB2ENR |= (1 << IOPAEN) | (1 << IOPBEN);
}

void delay(unsigned int count)
{
	volatile unsigned int i, j;
	for(i = 0; i < count; i++)
	{
		for(j = 0; j < 255; j++);
	}
}

